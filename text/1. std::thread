Kратко:

    Объект класса представляет собой один поток выполнения.

    Новый поток начинает выполнение сразу же после построения объекта std::thread. Выполнение начинается с функции верхнего уровня, которая передаётся в качестве аргумента в конструктор std::thread.

    Возвращаемое значение этой функции игнорируется, а если в ней будет брошено исключение, которое не будет обработано в этом же потоке, то вызовется std::terminate.

    Передать возвращаемое значение или исключение из нового потока наружу можно через std::promise или через глобальные переменные (работа с которыми потребует синхронизации, см. std::mutex и std::atomic).

    Объекты std::thread также могут быть не связаны ни с каким потоком (после default construction, move from, detach или join), и поток выполнения может быть не связан ни с каким объектом std::thread (после detach).

    Никакие два объекта std::thread не могут представлять один и тот же поток выполнения; std::thread нельзя копировать (не является CopyConstructible или CopyAssignable), но можно перемещать (является MoveConstructible и MoveAssignable). 


# Потоки запускаются созданием объекта std::thread, в котором определяется выполняемая в потоке задача. Как правило функция
void do_some_work();
std::thread my_thread(do_some_work);

# экземпляр класса с оператором вызова функции: 
## предоставленный функциональный объект копируется в хранилище, принадлежащее вновь созданному потоку выполнения, и вызывается оттуда.
 class background_task{
 public:
     void operator()() const {
         do_something();
         do_something_else();
     }
 };
 background_task f;
 std::thread my_thread(f);

# Лямбда 
 std::thread my_thread([]{
     do_something();
     do_something_else();
 });

# Чтобы передать параметр по ссылке, используем std::ref
 void update_data_for_widget(widget_id w, widget_data& data);
 std::thread t(update_data_for_widget,w,std::ref(data));

# Чтобы вызвать в отдельном потоке метод какого-ибо объекта, нужно передать указатель на объект в качестве первого аргумента этого метода:
 class X {
 public:
     void do_lengthy_work();
 };
 X my_x;
 std::thread t(&X::do_lengthy_work, &my_x);

# Еще один интересный сценарий предоставления аргументов применяется, когда аргументы нельзя скопировать, а можно только переместить. Примером может послужить тип std::unique_ptr, обеспечивающий автоматическое управление памятью для динамически выделяемых объектов. В одно и то же время на данный объект может указывать только один экземпляр std::unique_ptr, и когда этот экземпляр уничтожается, объект, на который он указывал, удаляется. Перемещающий конструктор и перемещающий оператор присваивания позволяют передавать права владения объектом между экземплярами std::unique_ptr. В результате этого исходный объект остается с нулевым указателем. Такое перемещение значений позволяет принимать объекты данного типа в качестве параметров функции или возвращать их из функций. Если исходный объект временный, перемещение выполняется автоматически, но если источником является именованное значение, передача должна быть запрошена напрямую путем вызова метода std::move(). В следующем примере показано использование std::move для передачи потоку права владения динамическим объектом:

 void process_big_object(std::unique_ptr<big_object>);
 std::unique_ptr<big_object> p(new big_object);
 p->prepare_data(42);
 std::thread t(process_big_object,std::move(p));

# std::thread::hardware_concurrency(). Она возвращает то количество потоков, которые действительно могут работать одновременно в ходе выполнения программы.

# std::thread::get_id() возвращает id потока. 

std::thread::native_handle() возвращает специфичный для операционной системы handle потока,который можно передавать в методы WinAPI или pthreads для более гибкого управления потоками. 